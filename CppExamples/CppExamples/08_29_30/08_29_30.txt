///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////

			29 Austos 2015 Cumartesi

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////


class exception {
public:
	virtual const char *what()const noexcept;

};

#include <iostream>
#include <string>


class FileError : public std::exception {
public:
	FileError(const std::string &fname) : mFileName{ fname } {}
	const std::string getMessage()const { return mExMessage; }
	virtual const char *what()const /*noexcept*/ override{ return mExMessage.c_str(); }
protected:
	void setMessage(const std::string &msg) { mExMessage = msg; }
private:
	std::string mFileName;
	std::string mExMessage;
};
//////////////////////////////////////////////////////////////////////////////////////////////////
class FileOpenError : public FileError {
public:
	FileOpenError(const std::string &fname) : FileError{ fname }
	{
		setMessage("unable to open file: " + fname);
	}
};
//////////////////////////////////////////////////////////////////////////////////////////////////
class FileReadError : public FileError {
public:
	FileReadError(const std::string fname, int lineNo) : FileError{ fname }
	{
		setMessage("Error in reading file : " + fname + " at line : " + std::to_string(lineNo));
	}
};


using namespace std;



int main()
{
	/*
	try {
		throw FileOpenError("ali.txt");
	}
	catch (FileError &r) {
		cout << r.what() << endl;
	}
	*/
	try {
		throw FileReadError{ "mehmet.txt", 67 };
	}
	catch (exception &r) {
		cout << r.what() << endl;
	}
	
	return 0;
}
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////


#include <iostream>

using namespace std;

void f1()
{
	throw 5;
}


void f2()
{
	try {
		f1();
	}
	catch (int x) {
		x++;
		throw;
	}
}



int main()
{
	try {
		f2();
	}
	catch (int a) {
		cout << "hata main'de yakalandi" << endl;
		cout << "a = " << a << endl;
	}

	return 0;
}
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


catch (Myexception &r) {
	/////
	throw r;
}


////
exception *p;
p = &myoutofrange;

throw *p;



/////////////////////////////////////////////////////////////
try {

}
catch (exception &r) {

		throw;
}


Bir nesne construct olurken constructor exception throw ederse construct edilen nesne iin
*this nesnesi iin destructor arlmaz.

class Elem {

};


class Myclass {
Elem e1, e2;
};

Myclass::Myclass() : 
{
	try {
	
	}
	catch() {
	}


}


#include <iostream>

using namespace std;

void func()
{
	try {
		//////////
		//////////
		//////////
	}
	catch (int) {


	}


}

void func()
try
{
		//////////
		//////////
		//////////
}
catch (int) {

}


#include <iostream>

using namespace std;

class Elem {
	int mx;
public:
	Elem(int x) : mx{ x } {
		throw 1;
	}
};

class Myclass {
	Elem me;
public:
	Myclass() : me{ 10 } {
		try {

		}
		catch (int x) {
			cout << "Myclass::Myclass()" << endl;
			cout << "hata nesnesi yakalandi" << endl;
		}
	}

};



int main()
{
	Myclass m;

	return 0;
}
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
#include <iostream>

using namespace std;

class Elem {
	int mx;
public:
	Elem(int x) : mx{ x } {
		throw 1;
	}
};

class Myclass {
	Elem me;
public:
	Myclass(int a) try : me{ a} 
	{
		
	}
	catch (int x) { 
			cout << "function try block.... " << endl;
			cout << "hata nesnesi yakalandi" << endl;
			throw bad_alloc();
	}

};



int main()
{
	Myclass m;

	return 0;
}
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////

Myclass::Myclass(AnotherClass x)
{

}




void func() throw(MathError, std::bad_alloc);
void foo() throw();
void g();

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////

				30 Agu 2015 Pazar

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
#include <iostream>
#include <vector>
#include <stdexcept>
#include <string>
#include <fstream>


using namespace std;

class Car {
public:
	virtual std::ostream &write(std::ostream &r)const = 0;
	friend std::ostream &operator<<(std::ostream &os, const Car &r)
	{
		return r.write(os);
	}
};

class Fiat : public Car {
public:
	std::ostream &write(std::ostream &os)const override {
		return os << "Fiat" << endl;
	}
};

class Audi : public Car {
public:
	std::ostream &write(std::ostream &os)const override {
		return os << "Audi" << endl;
	}
};

class Ferrari : public Car {
public:
	std::ostream &write(std::ostream &os)const override {
		return os << "Ferrari" << endl;
	}
};

class Bmw : public Car {
public:
	std::ostream &write(std::ostream &os)const override {
		return os << "Bmw" << endl;
	}
};


int main()
{
	Bmw mybmw;
	Fiat myfiat;
	Audi myaudi;
	Ferrari myf;

	cout << myfiat << myaudi << myf << mybmw;

	return 0;
}

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
#include <iostream>
#include <vector>
#include <stdexcept>
#include <string>
#include <fstream>


using namespace std;

//C++11
void f1();  //exception gnderebilir
void f2() noexcept;  //exception gndermeme taahht

void f3()
{
	cout << "f3()" << endl;
	throw 3;
}

void f2()noexcept
{
	
	cout << "f2 cagrildi" << endl;
	f3();
}


int main()
{
	try {
		f2();
	}
	catch (int a) {
		cout << "hata mainde yakalandi" << endl;
	}

	return 0;
}

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
#include <iostream>
#include <vector>
#include <stdexcept>
#include <string>
#include <fstream>


using namespace std;


class Myclass {
public:
	void func()const noexcept;
	virtual ~Myclass()noexcept;
};



int main()
{
	return 0;
}

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
#include <cstddef>
#include <iostream>

using namespace std;


class Element {
private:
	int mValue;
};

class Matrix {
public:
	Matrix(size_t width, size_t height);
	virtual ~Matrix();
private:
	size_t m_width;
	size_t m_height;
	Element **mMatrix;
};





Matrix::Matrix(size_t width, size_t height) : m_width(width), m_height(height) {
	mMatrix = new Element *[width];
	size_t i = 0;
	try {
		for (i = 0; i < width; ++i)
			mMatrix[i] = new Element[height];
	}
	catch (...) {
		cout << "exception cought int constructor..." << endl;
		cout << "clean up memory we already allocated... the destructor will never be called..." << endl;
		cout << "the upper bound of the for loop is the index of the last element in the mMatrix array that we tried "
			"to allocate (the one that failed) " << endl;
		for (size_t j = 0; j < i; ++j) {
			delete [] mMatrix[j];
		}
		delete []mMatrix;
		throw bad_alloc();
	}
}

Matrix::~Matrix()
{
	for (size_t i = 0; i < m_width; ++i) {
		delete[] mMatrix[i];
	}
	delete[]mMatrix;
}


#include <cstddef>
#include <ctime>

#include <iostream>

using namespace std;


class Car {
public:
	virtual ~Car() = default;
	//////
};


class Skoda : public Car {

};

class Audi : public Car {
public:
	void openSunRoof() {
		cout << "Audi'min sunroof'u acildi" << endl;
	}

};

class Dacia : public Car {

};


void func(Car *ptr)
{
	///////
	if (auto p = dynamic_cast<Audi *>(ptr))
		p->openSunRoof();
	///////
}



int main()
{
	srand(static_cast<unsigned int>(time(nullptr)));

	for (;;)
	{
		switch (rand() % 3) {
		case 0: cout << "Dacia case" << endl; func(new Dacia); break;
		case 1: cout << "Audi case" << endl; func(new Audi); break;
		case 2: cout << "Skoda case" << endl; func(new Skoda); break;
		}
		getchar();
	}
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#include <cstddef>
#include <ctime>

#include <iostream>

using namespace std;


class Car {
public:
	virtual ~Car() = default;
	//////
};


class Skoda : public Car {

};

class Audi : public Car {
public:
	void openSunRoof() {
		cout << "Audi'min sunroof'u acildi" << endl;
	}

};

class Dacia : public Car {

};


void func(Car &cr)
{
	///////
	try {
		Audi &ar = dynamic_cast<Audi &>(cr);
		ar.openSunRoof();
	}
	catch (bad_cast &r) {
		cout << "exception caught... : " << r.what() << endl;
	}
	///////
}



int main()
{
	Skoda s;

	func(s);


	return 0;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#include <cstddef>
#include <string>

#include <iostream>

using namespace std;

class Car {
public:
	virtual ~Car() = default;
};


class Mercedes : public Car {

};

class Fiat : public Car {

};


int main()
{
	Mercedes m;
	Car *ptr = &m;

	if (typeid(*ptr) == typeid(Mercedes))
		cout << "mercedes" << endl;
	else {
		cout << "Car" << endl;

	}

	return 0;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#include <cstddef>
#include <string>

#include <iostream>

using namespace std;

class Car {
public:
	virtual ~Car() = default;
};


class Mercedes : public Car {

};

class Fiat : public Car {

};


int main()
{
	Fiat f;
	Car *ptr = &f;

	cout << typeid(*ptr).name() << endl;

	return 0;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#include <cstddef>
#include <string>

#include <iostream>

using namespace std;


class Shape {
public:
	///////
	virtual ~Shape() = 0;
};

//bu global ilev polimorfik davran gsterecek
// eer iki Shape ayn trden ise
//ve znitelikleri de ayni ise true aksi durumda false deger dondurecek
//ornegin ikisi de ucgen ise ve iki ucgenin de kenarlari ayn uzunlukta ise true


bool operator==(const Shape &r1, const Shape &r2);

int main()
{

	return 0;
}