///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

			12 Eylul 2015 Cumartesi

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

class template
function template
/////////////////////////////////////7
template class (?)
template function (?)
/////////////////////////////////////7
template instantiation
template specialization


#include <string>
#include <iostream>


using namespace std;

template<typename T, typename U>
T func(T x, U y)
{
	cout << "master template" << endl;
	return T();
}

template<>
int func(int x, double y)
{
	cout << "acik ozellestirme" << endl;
	return 1;
}




int main()
{
	func(3, 4.5);

	return 0;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


namespace std {
	template<typename T>
	class Vector {

	};

	template<typename T>
	class Vector<T *> {

	};

	template<typename T>
	class Vector<T &> {

	};

	template<typename T>
	class Vector<T &&> {

	};

}


#include <string>
#include <iostream>

using namespace std;


template<typename T>
struct Myclass {
	Myclass()
	{
		cout << "master template" << endl;
		cout << "type T is" << typeid(T).name() << endl;
	}
};


template<typename T>
struct Myclass<T *> {
	Myclass()
	{
		cout << "secondary template" << endl;
	}
};


int main()
{
	Myclass<int> m1;
	Myclass<double *> m2;

	return 0;
} 


#include <string>
#include <iostream>

using namespace std;


template<typename T, typename U>
struct Myclass {
	Myclass()
	{
		cout << "master template" << endl;
		cout << "type T is " << typeid(T).name() << endl;
		cout << "type U is " << typeid(U).name() << endl;

	}
};

template<typename T>
struct Myclass<T, T>
{
	Myclass() {
		cout << "secondary template" << endl;
	}
};


int main()
{
	Myclass<int, double> m1;
	Myclass<double, double> m2;


	return 0;
}
//////////////////////////////////////////////
#include <string>
#include <iostream>

using namespace std;

template <typename T>
class Sclass {


};


template <typename T>
class Tclass {


};

template<typename T, template<typename> class C>
struct Myclass {
	C<T> mx;
	Myclass()
	{
		cout << typeid(mx).name() << endl;
	}
};


int main()
{
	Myclass<int, Tclass> m1;
	Myclass<double, Sclass> m2;

	return 0;
}


#include <string>
#include <list>
#include <vector>


#include <iostream>

using namespace std;

//typedef std::list<double> Dlist;
//typedef vector<Dlist> ListVec;

using Dlist = std::list<double>;
using ListVec = std::vector<Dlist>;


int main()
{
	ListVec myvec;


	return 0;
}


#include <string>



using namespace std;

template <typename T>
class Vector {

};

template<typename T>
using Vec = Vector<T>;

int main()
{
	Vector<int> vec1;
	Vec<int> vec2;

	return 0;
}

#include <string>



using namespace std;

template <typename T, typename U>
class Data{

};

template<typename T>
using IData = Data<T, int>;

int main()
{
	IData<double> x;

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
#include <string>



using namespace std;

//c++11 template alias

template <typename KeyType, typename ValueType>
class Map{

};

template<typename KeyType>
using Smap = map<Keytype, int>;


int main()
{
	Map<string, int> mymap;
	Smap<double> s;

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
#include <string>



using namespace std;

template<int size>
class Tclass {

};



int main()
{
	Tclass<10> t1;
	Tclass<20> t2;
	///
	t1 = t2;   //gecersiz

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
#include <string>
#include <vector>

using namespace std;

class Myclass {
public:
	void func(int x) {}
};

int main()
{
	Myclass m;

	m.func(10);

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
#include <string>
#include <vector>

using namespace std;


class Myclass {
public:
	template<class T>
	void func(T x) {}
};

int main()
{
	Myclass m;

	m.func(10);
	m.func(2.3);
	string s;
	//
	m.func(s);


	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
#include <string>
#include <vector>

using namespace std;

template<class T>
class Myclass {
public:
	template<class U>
	void func(U x) {}
};

int main()
{
	Myclass<int> m;
	string s{ "necxati" };

	m.func(s);

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
#include <string>
#include <iostream>
#include <tuple>

using namespace std;

class Date {};

template<typename ValueType>
using spair = std::pair<std::string, ValueType>;



int main()
{
	spair<double> p1;

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
#include <string>
#include <iostream>
#include <bitset>

using namespace std;



int main()
{
	bitset<34> x;

	x = ~x;

	if (x.all())
		cout << "dogru" << endl;
	else
		cout << "yanlis" << endl;





	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <vector>
#include <list>
#include <set>

using namespace std;

class Myclass {};

typedef vector<Myclass> Cont;


int main()
{
	cout << typeid(Cont::value_type).name() << endl;

	return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <vector>
#include <list>
#include <set>

using namespace std;


template<typename T>
class Myclass {
	T mx;
public:

	Myclass(const T &r) : mx{ r } {}
	T get()const { return mx;}
	Myclass &set(const T &r)
	{
		mx = r;
	}
	friend bool operator==(const Myclass &r1, const Myclass &r2);
};


template<typename T>
bool operator==(const Myclass<T> &r1, const Myclass<T> &r2)
{
	return r1.mx == r2.mx;
}


int main()
{
	Myclass<int> m1(19), m2(34);

	if (m1 == m2)
		cout << "dogru" << endl;

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

				13 Eyll 2015 Pazar

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


class Myclass {
	template <typename T>  //Tclass in tum acilimlar Myclass snfnn
	friend class Tclass;   //private bolumune erisebilir
};

int main()
{

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

template<typename>
class Tclass;

class Myclass {
	friend class Tclass<Myclass>;  
	//nontemplate Myclass snf class Template Tclass'n Myclass acilimina
	//arkadaslik veriyor.
};



int main()
{

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

template<typename>
class Tclass {
	friend class Myclass;
	//Tclass ablonundan elde edilecek tm snflarn
	//private blmne nontemplate Myclass snf eriebilir
};



int main()
{

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

template<typename T>
class MyclassPtr;

template<typename T>
class Myclass{
	friend class MyclassPtr<T>;
	//birebir arkadaslik 
	//ornegin Myclass<string> MyclassPtr<string> a arkadalk veriyor
};



int main()
{

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

template<typename T>
class MyclassPtr;

template<typename T>
class Myclass{
	template<typename U>
	friend class MyclassPtr<U>;
	//coklu arkadaslik 
};



int main()
{

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>

using namespace std;

#include <iostream>

using namespace std;


template<typename T>
ostream &print(ostream &os, const T &t)
{
	return os << t << endl;
}

template <typename T, typename... Args>
ostream &print(ostream &os, const T &t, const Args&... rest)
{
	os << t << ", "; 
	return print(os, rest...); 
}

int main()
{
	print(cout, 10, 34., 67L);

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

namespace std {
template<typename T>
class vector {
public:
	class iterator {
	public:
		operator++()
		operator*()
		operator !=()
		///
	};
	iterator begin();
	iterator end();
};

}


template <class Category, class T, class Distance = ptrdiff_t, class Pointer = T*, class Reference = T&>
struct iterator {
	typedef T         value_type;
	typedef Distance  difference_type;
	typedef Pointer   pointer;
	typedef Reference reference;
	typedef Category  iterator_category;
};

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

#include <iostream>

using namespace std;


// this function must be declared before the variadic version of print is defined
template<typename T>
ostream &print(ostream &os, const T &t)
{
	return os << t; // no separator after the last element in the pack
}

// this version of print will be called for all but the last element in the pack
template <typename T, typename... Args>
ostream &print(ostream &os, const T &t, const Args&... rest)
{
	os << t << ", "; // print the first argument
	return print(os, rest...); // recursive call; print the other 	arguments
}

int main()
{
	print(cout, 45, "ali", 3.87, 'A');

	
	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <string>


using namespace std;

template<typename T>
T summer(T v) 
{
	return v;
}

template<typename T, typename... Args>
T summer(T first, Args... args) {
	return first + summer(args...);
}

int main()
{
	cout << summer(10, 20, 30, 80, 17) << endl;
	std::string s1 = "nec", s2 = "ati ", s3 = "Er";
	cout << summer(s1, s2, s3, "gin") << endl;

	return 0;
}